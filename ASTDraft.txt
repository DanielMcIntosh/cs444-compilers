format for grammar based AST description:
RuleLHS: ClassItProduces(superclass)(other notes)
	RuleRHS1
	RuleRHS2
	...

In this document, the "parent" class is refering to AST tree parent/child relationships,
not inheritance. For inheritance, superclass and subclass are used instead.

A rule is bypassed if the RuleRHS is a single non-terminal node.
if ClassItProduces is prefixed with a -, it means that none of the rules with this RHS are
ever used to construct an AST node.
e.g.
Type: -Type(subclass of Node)
	PrimitiveType
	ReferenceType

If a ClassItProduces is prefixed with a '.' it means it is not a full-fledged AST node,
just a pseudoASTNode.
e.g. Modifiers might get converted to vector<Modifier> instead.


Notes/todo's
maybe change inheritance such that any statements which introduce a new scope share a parent class/inherit from block
Type class includes void - the grammar prevents void from being used for things other than return type
replace list types with a template (1 type, and 2 ints)?

===========================AST INHERITANCE===========================
CompilationUnit: Node
Expression: Node
ImportDeclaration: Node
MemberDeclaration: Node
Modifier: Node
Statement: Node
Type: Node
TypeDeclaration: Node

PrimitiveType: Type

ConstructorDeclaration: MemberDeclaration
FieldDeclaration: MemberDeclaration
MethodDeclaration: MemberDeclaration

Block: Statement
ExpressionStatement: Statement
LocalVariableDeclarationStatement: Statement
ReturnStatement: Statement
ConditionalStatement: Statement

ForStatement: ConditionalStatement
IfThenElseStatement: ConditionalStatement

AssignmentExpression: Expression
BinaryExpression: Expression
CastExpression: Expression
LocalVariableDeclaration: Expression
Name: Expression(convertible to Type?)
Primary: Expression
UnaryExpression: Expression
UnaryExpression: Expression

ArrayAccess: Primary
ArrayCreationExpression: Primary
ClassInstanceCreationExpression: Primary
FieldAccess: Primary
Literal: Primary
MethodInvocation: Primary
This: Primary

====================GRAMMAR BASED AST DESCRIPTION====================
Goal: DNE
	CompilationUnit

Literal: Literal?(subclass of Primary)
	IntegerLiteral
	BooleanLiteral
	CharacterLiteral
	StringLiteral
	NullLiteral

Type: -Type(subclass of Node)
	PrimitiveType
	ReferenceType

PrimitiveType: PrimitiveType?(subclass of Type)
	</i>boolean<i>
	</i>byte<i>
	</i>short<i>
	</i>int<i>
	</i>char<i>

ReferenceType: -Type(subclass of Node)
	ClassOrInterfaceType
	ArrayType

ClassOrInterfaceType: -Type(subclass of Node)
	Name

ClassType: -Type(subclass of Node)
	ClassOrInterfaceType

InterfaceType: -Type(subclass of Node)
	ClassOrInterfaceType

ArrayType: +ArrayType(subclass of Type)(convert to bool in Type during a second pass?)
	PrimitiveType </i>[<i> </i>]<i>
	Name </i>[<i> </i>]<i>

Name: Name(subclass of Expression, convertible to Type?)
	Identifier
	Name </i>.<i> Identifier

CompilationUnit: CompilationUnit(subclass of Node)

	PackageDeclaration
	ImportDeclarations
	PackageDeclaration ImportDeclarations
	TypeDeclaration
	PackageDeclaration TypeDeclaration
	ImportDeclarations TypeDeclaration
	PackageDeclaration ImportDeclarations TypeDeclaration

ImportDeclarations: .ImportDeclarations(vector in parent class)
	ImportDeclaration
	ImportDeclarations ImportDeclaration

PackageDeclaration: +PackageDeclaration(subclass of Node)
	</i>package<i> Name </i>;<i>

ImportDeclaration: -ImportDeclaration(subclass of Node)
	SingleTypeImportDeclaration
	TypeImportOnDemandDeclaration

SingleTypeImportDeclaration: ImportDeclaration(subclass of Node)
	</i>import<i> Name </i>;<i>

TypeImportOnDemandDeclaration: ImportDeclaration(subclass of Node)
	</i>import<i> Name </i>.<i> </i>*<i> </i>;<i>

TypeDeclaration: TypeDeclaration(subclass of Node)
	ClassDeclaration
	InterfaceDeclaration
	</i>;<i>

Modifiers: .Modifiers(subclass of Node)(vector in parent class)
	Modifier
	Modifiers Modifier

Modifier: Modifier?(subclass of Node)
	</i>public<i>
	</i>protected<i>
	</i>static<i>
	</i>abstract<i>
	</i>final<i>
	</i>native<i>

ClassDeclaration: TypeDeclaration(subclass of Node)
	</i>class<i> Identifier ClassBody
	Modifiers </i>class<i> Identifier ClassBody
	</i>class<i> Identifier </i>extends<i> ClassType ClassBody
	Modifiers </i>class<i> Identifier </i>extends<i> ClassType ClassBody
	</i>class<i> Identifier </i>implements<i> InterfaceTypeList ClassBody
	Modifiers </i>class<i> Identifier </i>implements<i> InterfaceTypeList ClassBody
	</i>class<i> Identifier </i>extends<i> ClassType </i>implements<i> InterfaceTypeList ClassBody
	Modifiers </i>class<i> Identifier </i>extends<i> ClassType </i>implements<i> InterfaceTypeList ClassBody

InterfaceTypeList: .InterfaceTypeList(vector of InterfaceType in parent class)
	InterfaceType
	InterfaceTypeList </i>,<i> InterfaceType

ClassBody: .TypeBody(vector of MemberDeclaration in parent class)
	</i>{<i> </i>}<i>
	</i>{<i> ClassMemberDeclarations </i>}<i>

ClassMemberDeclarations: .MemberDeclarations(vector of MemberDeclaration in parent class)
	ClassMemberDeclaration
	ClassMemberDeclarations ClassMemberDeclaration

ClassMemberDeclaration: -MemberDeclaration(subclass of Node)
	FieldDeclaration
	MethodDeclaration
	ConstructorDeclaration

FieldDeclaration: FieldDeclaration(subclass of MemberDeclaration)
	Type VariableDeclarator </i>;<i>
	Modifiers Type VariableDeclarator </i>;<i>

VariableDeclarator: .VariableDeclarator(subclass of Node)(members get moved into parent class)
	Identifier
	Identifier </i>=<i> Expression

MethodDeclaration: MethodDeclaration(subclass of MemberDeclaration)
	MethodHeader MethodBody

MethodHeader: .MethodHeader(subclass of Node)(members get moved into parent class)
	Type MethodDeclarator
	Modifiers Type MethodDeclarator
	</i>void<i> MethodDeclarator
	Modifiers </i>void<i> MethodDeclarator

MethodDeclarator: .MethodDeclarator(subclass of Node)(members get moved into parent class)
	Identifier </i>(<i> </i>)<i>
	Identifier </i>(<i> FormalParameterList </i>)<i>

FormalParameterList: .FormalParameterList(vector of VariableDeclaration in parent class)
	FormalParameter
	FormalParameterList </i>,<i> FormalParameter

FormalParameter: VariableDeclaration(subclass of Expression)
	Type Identifier

MethodBody: -Statement(subclass of Node)
	Block
	AbstractMethodBody

AbstractMethodBody: .AbstractMethodBody(subclass of Statement)(just leave method body NULL)
	</i>;<i>

ConstructorDeclaration: ConstructorDeclaration?(subclass of MemberDeclaration)(maybe use MethodDeclaration instead?)
	ConstructorDeclarator Block
	Modifiers ConstructorDeclarator Block

ConstructorDeclarator: .MethodDeclarator(subclass of Node)(members get moved into parent class)
	Identifier </i>(<i> </i>)<i>
	Identifier </i>(<i> FormalParameterList </i>)<i>

InterfaceDeclaration: TypeDeclaration(subclass of Node)
	</i>interface<i> Identifier InterfaceBody
	Modifiers </i>interface<i> Identifier InterfaceBody
	</i>interface<i> Identifier ExtendsInterfaces InterfaceBody
	Modifiers </i>interface<i> Identifier ExtendsInterfaces InterfaceBody

ExtendsInterfaces: .ExtendsInterfaces(vector of InterfaceType in parent class)
	</i>extends<i> InterfaceType
	ExtendsInterfaces </i>,<i> InterfaceType

InterfaceBody: .TypeBody(vector of MemberDeclaration in parent class)
	</i>{<i> </i>}<i>
	</i>{<i> InterfaceMemberDeclarations </i>}<i>

InterfaceMemberDeclarations: .InterfaceMemberDeclarations(vector of MemberDeclaration in parent class)
	InterfaceMemberDeclaration
	InterfaceMemberDeclarations InterfaceMemberDeclaration

InterfaceMemberDeclaration: -MethodDeclaration(subclass of MemberDeclaration)
	AbstractMethodDeclaration

AbstractMethodDeclaration: MethodDeclaration(subclass of MemberDeclaration)
	MethodHeader </i>;<i>

Block: Block(subclass of Statement)(can't always be flatened into parent because it introduces a new scope)
	</i>{<i> </i>}<i>
	</i>{<i> BlockStatements </i>}<i>

BlockStatements: .BlockStatements(vector of BlockStatement in parent class)
	BlockStatement
	BlockStatements BlockStatement

BlockStatement: -Statement(subclass of Node)
	LocalVariableDeclarationStatement
	Statement

LocalVariableDeclarationStatement: LocalVariableDeclarationStatement(subclass of Statement)
	LocalVariableDeclaration </i>;<i>

LocalVariableDeclaration: VariableDeclaration(subclass of Expression)
	Type VariableDeclarator

Statement: -Statement(subclass of Node)
	StatementWithoutTrailingSubstatement
	IfThenStatement
	IfThenElseStatement
	WhileStatement
	ForStatement

StatementNoShortIf: -Statement(subclass of Node)
	StatementWithoutTrailingSubstatement
	IfThenElseStatementNoShortIf
	WhileStatementNoShortIf
	ForStatementNoShortIf

StatementWithoutTrailingSubstatement: -Statement(subclass of Node)
	Block
	EmptyStatement
	ExpressionStatement
	ReturnStatement

EmptyStatement: ExpressionStatement(subclass of Statement)(leave StatementExpression NULL)
	</i>;<i>

ExpressionStatement: ExpressionStatement(subclass of Statement)
	StatementExpression </i>;<i>

StatementExpression: -Expression(subclass of Node)
	Assignment
	MethodInvocation
	ClassInstanceCreationExpression

IfThenStatement: ConditionalStatement?(subclass of Statement)
	</i>if<i> </i>(<i> Expression </i>)<i> Statement

IfThenElseStatement: IfThenElseStatement?(subclass of ConditionalStatement)
	</i>if<i> </i>(<i> Expression </i>)<i> StatementNoShortIf </i>else<i> Statement

IfThenElseStatementNoShortIf: IfThenElseStatement?(subclass of ConditionalStatement)
	</i>if<i> </i>(<i> Expression </i>)<i> StatementNoShortIf </i>else<i> StatementNoShortIf

WhileStatement: ConditionalStatement?(subclass of Statement)
	</i>while<i> </i>(<i> Expression </i>)<i> Statement

WhileStatementNoShortIf: ConditionalStatement?(subclass of Statement)
	</i>while<i> </i>(<i> Expression </i>)<i> StatementNoShortIf

ForStatement: ForStatement?(subclass of ConditionalStatement)
	</i>for<i> </i>(<i> </i>;<i> </i>;<i> </i>)<i> Statement
	</i>for<i> </i>(<i> ForInit </i>;<i> </i>;<i> </i>)<i> Statement
	</i>for<i> </i>(<i> </i>;<i> Expression </i>;<i> </i>)<i> Statement
	</i>for<i> </i>(<i> ForInit </i>;<i> Expression </i>;<i> </i>)<i> Statement
	</i>for<i> </i>(<i> </i>;<i> </i>;<i> ForUpdate </i>)<i> Statement
	</i>for<i> </i>(<i> ForInit </i>;<i> </i>;<i> ForUpdate </i>)<i> Statement
	</i>for<i> </i>(<i> </i>;<i> Expression </i>;<i> ForUpdate </i>)<i> Statement
	</i>for<i> </i>(<i> ForInit </i>;<i> Expression </i>;<i> ForUpdate </i>)<i> Statement

ForStatementNoShortIf: ForStatement?(subclass of ConditionalStatement)
	</i>for<i> </i>(<i> </i>;<i> </i>;<i> </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> ForInit </i>;<i> </i>;<i> </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> </i>;<i> Expression </i>;<i> </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> ForInit </i>;<i> Expression </i>;<i> </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> </i>;<i> </i>;<i> ForUpdate </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> ForInit </i>;<i> </i>;<i> ForUpdate </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> </i>;<i> Expression </i>;<i> ForUpdate </i>)<i> StatementNoShortIf
	</i>for<i> </i>(<i> ForInit </i>;<i> Expression </i>;<i> ForUpdate </i>)<i> StatementNoShortIf

ForInit: -Expression(subclass of Node)
	StatementExpression
	LocalVariableDeclaration

ForUpdate: -Expression(subclass of Node)
	StatementExpression

ReturnStatement: ReturnStatement(subclass of Statement)
	</i>return<i> </i>;<i>
	</i>return<i> Expression </i>;<i>

Primary: -Primary(subclass of Expression)
	PrimaryNoNewArray
	ArrayCreationExpression

PrimaryNoNewArray: -Primary(subclass of Expression)
	Literal
	This
	ParethesizedExpression
	ClassInstanceCreationExpression
	FieldAccess
	MethodInvocation
	ArrayAccess

This: This(subclass of Primary)
	</i>this<i>

ParenthesizedExpression: .ParenthesizedExpression(subclass of Primary)(maybe move expression into parent?)
	</i>(<i> Expression </i>)<i>

ClassInstanceCreationExpression: ClassInstanceCreationExpression(subclass of Primary)
	</i>new<i> ClassType </i>(<i> </i>)<i>
	</i>new<i> ClassType </i>(<i> ArgumentList </i>)<i>

ArgumentList: .ArgumentList(replace with vector<Expression> in parent node)
	Expression
	ArgumentList </i>,<i> Expression

ArrayCreationExpression: ArrayCreationExpression(subclass of Primary)
	</i>new<i> PrimitiveType </i>[<i> Expression </i>]<i>
	</i>new<i> ClassOrInterfaceType </i>[<i> Expression </i>]<i>

FieldAccess: FieldAccess(subclass of Primary)
	Primary </i>.<i> Identifier

MethodInvocation: MethodInvocation(subclass of Primary)
	Name </i>(<i> </i>)<i>
	Name </i>(<i> ArgumentList </i>)<i>
	Primary </i>.<i> Identifier </i>(<i> </i>)<i>
	Primary </i>.<i> Identifier </i>(<i> ArgumentList </i>)<i>

ArrayAccess: ArrayAccess(subclass of Primary)
	Name </i>[<i> Expression </i>]<i>
	PrimaryNoNewArray </i>[<i> Expression </i>]<i>

UnaryExpression: UnaryExpression(subclass of Expression)
	</i>-<i> UnaryExpression
	UnaryExpressionNotPlusMinus

UnaryExpressionNotPlusMinus: UnaryExpression(subclass of Expression)
	Primary
	Name
	</i>!<i> UnaryExpression
	CastExpression

CastExpression: CastExpression(subclass of Expression)
	</i>(<i> PrimitiveType </i>)<i> UnaryExpression
	</i>(<i> PrimitiveType </i>[<i> </i>]<i> </i>)<i> UnaryExpression
	</i>(<i> Expression </i>)<i> UnaryExpressionNotPlusMinus
	</i>(<i> Name </i>[<i> </i>]<i> </i>)<i> UnaryExpressionNotPlusMinus

MultiplicativeExpression: BinaryExpression(subclass of Expression)
	UnaryExpression
	MultiplicativeExpression </i>*<i> UnaryExpression
	MultiplicativeExpression </i>/<i> UnaryExpression
	MultiplicativeExpression </i>%<i> UnaryExpression

AdditiveExpression: BinaryExpression(subclass of Expression)
	MultiplicativeExpression
	AdditiveExpression </i>+<i> MultiplicativeExpression
	AdditiveExpression </i>-<i> MultiplicativeExpression

RelationalExpression: BinaryExpression(subclass of Expression)
	AdditiveExpression
	RelationalExpression </i>&lt;<i> AdditiveExpression
	RelationalExpression </i>&gt;<i> AdditiveExpression
	RelationalExpression </i>&lt;=<i> AdditiveExpression
	RelationalExpression </i>&gt;=<i> AdditiveExpression
	RelationalExpression </i>instanceof<i> ReferenceType

EqualityExpression: BinaryExpression(subclass of Expression)
	RelationalExpression
	EqualityExpression </i>==<i> RelationalExpression
	EqualityExpression </i>!=<i> RelationalExpression

AndExpression: BinaryExpression(subclass of Expression)
	EqualityExpression
	AndExpression </i>&amp;<i> EqualityExpression

InclusiveOrExpression: BinaryExpression(subclass of Expression)
	AndExpression
	InclusiveOrExpression </i>|<i> ExclusiveOrExpression

ConditionalAndExpression: BinaryExpression(subclass of Expression)
	InclusiveOrExpression
	ConditionalAndExpression </i>&amp;&amp;<i> EqualityExpression

ConditionalOrExpression: BinaryExpression(subclass of Expression)
	ConditionalAndExpression
	ConditionalOrExpression </i>||<i> ConditionalAndExpression

AssignmentExpression: -Expression(subclass of Node)
	ConditionalOrExpression
	Assignment

Assignment: AssignmentExpression(subclass of Expression)
	LeftHandSide </i>=<i> AssignmentExpression

LeftHandSide: -Expression(subclass of Node)
	Name
	FieldAccess
	ArrayAccess

Expression: -Expression(subclass of Node)
	AssignmentExpression
